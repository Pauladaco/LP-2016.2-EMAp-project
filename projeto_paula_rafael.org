#+Title: Projeto: Tradução de artigo para Racket

#+Author: Paula Daco e Rafael Mesquita

* Introdução

Neste projeto, vamos implementar em Racket três pseudocódigos do /essay/ "Algorithm Design Techniques" da coluna "Programming Pearls" da revista da Association for Computing Machinery, escrito pelo cientista da computação Jon Bentley, em 1984. 

A coletânea dos textos da "Programming Pearls" é um clássico da commputação, citado por quase 300 papers da área, mas "Algorithm Design Techniques" merece um destaque especial, pois apresenta a discussão sobre complexidade computacional, algoritmos e técnicas de design de algoritmos de forma acessível e a exemplifica através de um problema específico. 

Pensar complexidade e algoritmos é fundamental, permitindo que, com a técnica correta, lide-se com problemas até então considerados intratáveis. 

* O problema do subvetor máximo e implementação do primeiro algoritmo

O problema envolve calcular, dada uma lista, a maior soma em uma sequência de elementos dessa lista. Podemos pensar a lista enquanto um vetor e, assim, queremos identificar o subvetor que contenha a maior soma possível. Os elementos do vetor fazem parte do conjunto de númerosreais, já que, se o vetor fosse composto apenas por números positivos ou números negativos, a solução seria, necessariamente, o próprio vetor (se o vetor for positivo) ou 0 (se o vetor for negativo). 

O primeiro algoritmo que implementamos possui ordem cúbica de grandeza (O(N³)). Percebe-se que a essência deste algoritmo é utilizar =for= dentro de =for=, ocasionando assim, várias recursões durante o processo. Para começar, tivemos de implementar uma função que chamamos de =X=. Esta, por sua vez, é responsável por fazer a soma dos elementos no intervalo especificado. Para conseguirmos especificar o intervalo, criamos dois ponteiros: um que aponta para o início do intervalo e outro que aponta para o final.

*Algoritmo O(N³)*
#+BEGIN_SRC scheme
 (define (X lista ptr1 ptr2)
  (define (aux-X lista ptr1 ptr2 counter)
    (if (equal? ptr1 ptr2)
        counter
        (aux-X lista ptr1 (- ptr2 1) (+ counter (list-ref lista (- ptr2 1))))))
  (aux-X lista ptr1 ptr2 (list-ref lista (- ptr1 1))))


(define (MaxSoFar-1 lst)
  (let ((p 0))
  (if (null? lst)
      empty
      (for ((i (+ (length lst) 1))
                 #:when (> i 0))
        (for ((j (range i (+ (length lst) 1))))
          (if (> (X lst i j) p)
                    (begin (set! p (X lst i j)))
                    empty))))
    p))
#+END_SRC

A função principal, ou seja, a função que retorna o subvetor de maior soma é a =MaxSoFar=. Esta usa a função =X= para calcular a soma dos intervalos. Os intervalos são feitos pelo uso de dois =for= o primeiro gera um =i= de 1 até =N=, e o segundo gera um =j= de =i= até =N=, assim temos intervalos de =i= até =j= que cobrem todas as possibilidades de subvetores possíveis. O subvetor de soma máxima é encontrado com o uso da variável =p=, sempre que a soma de um intervalo é maior que a maior soma já encontrada o =p= se atualiza. No fim desse loop o =p= é a soma do subvetor de maior soma.

* O segundo algoritmo

Neste algoritmo, temos uma ordem de grandeza quadrática(*O(N²)*). A ideia nos pareceu a mesma, com a sutileza da criação que da variável temporária que guarda a soma para que a variável de estado principal /MaxSoFar/ seja atualizada conforme o valor for maior que o já estabelecido. Fizemos uma implementação com arrays. A função =X-array= é análoga a função =X= do código acima, apenas adaptada para trabalhar com /arrays/.

#+BEGIN_SRC scheme

(require math/array)

(define (CumArray x)
  (let ((Sum 0)
        (MaxSoFar 0))
    (begin (for ((L (range 1 (+ (array-size x) 1))))
             (for ((U (range L (+ (array-size x) 1)))
                   #:when(> U L))
               (begin (set! Sum (X-array x L U))
                      (set! MaxSoFar (max MaxSoFar Sum)))))
           MaxSoFar)))

(define (X-array arr ptr1 ptr2)
  (define (auxX-array arr ptr1 ptr2 counter)
    (if (equal? ptr1 ptr2)
        counter
        (auxX-array arr ptr1 (- ptr2 1) (+ counter (array-ref arr (vector (- ptr2 1)))))))
  (auxX-array arr ptr1 ptr2 (array-ref arr (vector (- ptr1 1)))))

* A estratégia do terceiro algoritmo

O terceiro algoritmo implementado tem uma ordem O(N log(N)). É baseada na ideia de dividir a lista ao meio e calcular a maior soma na primeira metade, na segunda metade e por fim, calcular a maior soma que passe pelo meio onde a lista incial foi dividida. Esse tipo de algoritmo é conhecido como algoritmo de /divisão e conquista/. A seguir está o algoritmo implementado com listas:


*Algoritmo O(Nlog(N))*
#+BEGIN_SRC scheme
(define (MaxSum lst)
  (define (createlist lst)
    (let ((k (length lst)))
      (define (aux lst1 lst2 counter)
        (if (equal? counter 0)
            (list lst1 lst2)
            (aux (append lst1 (list (car lst2))) (cdr lst2) (- counter 1))))
      (if (even? k)
          (aux (list (car lst)) (cdr lst) (- (/ k 2) 1))
          (aux (list (car lst)) (cdr lst) (- (/ (+ k 1) 2) 1)))))
  (define (aux-sum lst1 lst2 sum1 sum2 maxtoleft maxtoright maxcrossing)
    (cond ((equal? (length lst1) 1)
           maxcrossing)
          (else (begin (for ((i (range (length lst2))))
                         (begin (set! sum1 (+ sum1 (list-ref lst2 i)))
                                (set! maxtoright (max maxtoright sum1))))
                       (for ((j (range (length lst1) 0 -1)))
                         (begin (set! sum2 (+ sum2 (list-ref lst1 (- j 1))))
                                (set! maxtoleft (max maxtoleft sum2))))
                       (set! maxcrossing (+ maxtoright maxtoleft))
                       (max (MaxSum lst1)
                            (MaxSum lst2)
                            maxcrossing)))))
  (let ((p (createlist lst)))
    (aux-sum (normalize (car p)) (normalize (cadr p)) 0 0 0 0 0)))
    
(define (normalize lst)
  (if (and (odd? (length lst)) (> (length lst) 1))
      (append lst '(0))
      lst))

#+END_SRC

Para melhor compreensão, vamos explicar melhor o objetivo da implementação do algoritmo a partir da =MaxSum=. A ideia é:

1. Dividir a lista ao meio, criando "vetores" (na verdade, subvetores do vetor original, que foi implementado como uma lista);
2. Calcular a maior soma em cada vetor através de um subvetor que comece pelo primeiro termo. No caso de vetores não-negativos, o subvetor é o próprio vetor;
3. Calcular a maior soma que passe pelo intervalo intermediário onde foi dividida a lista;
4. A ideia principal é: fazer esses três passos acima com os vetores que tem tamanho maior que 1. 

Ou seja, inicializamos um vetor, dividindo-o na metade e fazendo todo esse processamento acima descrito. Perceba que, após dividi-lo, temos dois outros vetores e, supondo que eles tenham tamanhos maior que 1, temos que fazer o mesmo processo com cada um deles.

** Por que a função /normalize/ foi criada?
A função =normalize= foi criada com o objetivo de facilitar o processamento do código, tendo em vista que haveria muitas divisões por dois(assumindo que os vetores sejam grandes). Suponhamos que queremos trabalhar com um vetor de tamanho 6. Este vetor é par e por isso, podemos dividi-lo por 2. Porém, ficaremos com dois vetores de tamanho 3 e sabendo que teremos de parti-lo novamente, teremos problemas(3/2=1,5). Com o intuito de evitar essas contas com decimais, criamos a =normalize= para tornar os vetores de tamanhos ímpares em tamanhos pares acrescentando 0, já que este é um elemento neutro da soma.

* Implementação do quarto algoritmo

Nesta implementação, temos um código com ordem de grandeza *O(N)*. Sua essência é trabalhar com /arrays/ e é fundamentado na seguinte ideia: consideremos a soma de um intervalo X[I] e consideremos ainda, que essa seja a maior soma. No artigo, o autor diz que se a maior soma encontra-se em X[I], a segunda maior soma tem que ser encontrada em X[I-1]. Com essa ideia em mente, criamos uma função que percorre a lista uma única vez(este é o objetivo do /counter3/, que começa como o valor do tamanho do array), guardando apenas a maior soma através do uso recorrente da função =max= na variável =MaxSoFar=, após ser atualizada pela variável =MaxEndingHere=. Para que tal operação seja possível, precisamos da biblioteca /math-array/.

*Algoritmo O(N))*
#+BEGIN_SRC scheme
(require math/array)

(define (MaxSoFar lst)
  (let ((p (list->array lst))
        (MaxSoFar 0)
        (MaxEndingHere 0))
    (define (aux arr counter1 counter2 counter3)
      (if (equal? counter3 0)
          (max counter1 counter2)
          (aux arr (max counter1 counter2)
               (max MaxEndingHere (+ counter2 (array-ref arr (vector (- counter3 1))))) (- counter3 1))))
    (aux p MaxSoFar MaxEndingHere (array-size p))))

#+END_SRC

* Tabela com resultados dos algoritimos

| Algoritimo               |     | 1           | 2           | 3             |
|--------------------------+-----+-------------+-------------+---------------|
|                          |     |             |             |               |
| Run Time (milissegundos) |     | 0,00015.N^3 | 0,4.Nlog(N) | 0,04.N        |
|--------------------------+-----+-------------+-------------+---------------|
|                          |     |             |             |               |
| Time to solve            | N^2 | 150 ms      | 80 ms       | 4 ms          |
| problem of size          | N^3 | 2.5 min     | 1.2 s       | 40 ms         |
|                          | N^4 | 41 hrs      | 16 s        | 0.4 s         |
|                          | N^5 | 4.8 yrs     | 3.3 min     | 4 s           |
|                          | N^6 | 4.8 mill    | 40 min      | 40 s          |
|--------------------------+-----+-------------+-------------+---------------|
|                          |     |             |             |               |
| Max problem solved in    | s   | 188         | 852         | 25,000        |
|                          | min | 736         | 33,179      | 1,500,000     |
|                          | hr  | 2,884       | 1,460,000   | 90,000,000    |
|                          | day | 8,320       | 28,948,135  | 2,160,000,000 |
|--------------------------+-----+-------------+-------------+---------------|
|                          |     |             |             |               |
| If N multiplies by 1O,   |     | 1000        | 10+         | 10            |
| time multiplies by       |     |             |             |               |
|--------------------------+-----+-------------+-------------+---------------|
|                          |     |             |             |               |
| If time multiplies by    |     | 2.15        | 10-         | 10            |
| 1O, N multiplies by      |     |             |             |               |


* Gráficos

Os gráficos mostram a relação tamanho do vetor(N) /versus/ tempo de execução(t).

*Gráfico com todos os algoritimos*

Nesse gráfico fica claro que o primeiro algoritimo ganha muito mais tempo de execução com o aumento do vetor do que os outros dois algoritimos.

[[https://raw.githubusercontent.com/Pauladaco/LP-2016.2-EMAp-project/master/Gr-ficos/complexidade-1-2-3.png]]

*Gráfico com os algoritimos 2 e 3*

No gráfico anterior a diferença de complexidade entre os algoritimos 2 e 3 não estava clara. Porém nesse, como inclui apenas esses dois algoritimos, é possivel ver a diferença.

[[https://raw.githubusercontent.com/Pauladaco/LP-2016.2-EMAp-project/master/Gr-ficos/Complexidade-2-3.png]]
